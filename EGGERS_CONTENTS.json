{"home":{"content":"# Servers 101\n\nWelcome to **Lecture 24**! Here is a brief class breakdown.\n\n## Learning Objectives\n\n1. What is a server? How does it work?\n2. How do we build our own server with some simple **GET** and **POST** request functionality?\n\n## To Do Today\n\n* ### [Warmup](#warmup)\n* ### [Server Basics](#server-basics)\n* ### [Simple GET Requests](#simple-get-requests)\n* ### [Routing](#routing)\n* ### [Simple POST Requests](#simple-post-requests)\n* ### [Serving a full webpage](#serving-a-full-webpage)\n* ### [Serving JSON content](#serving-json-content)\n\n","idx":0},"title":{"content":"Servers 101","idx":1},"desc":{"content":"A quick introduction to serving and routing in NodeJS","idx":2},"warmup":{"content":"# Warmup\n\nLet's begin with a few short exercises.\n\n## Exercise 1\n\nCreate a new folder.\n\n```bash\nmkdir node-server && cd node-server\n```\n\nInitialize your project inside this folder.\n\n```bash\nnpm init\n```\n**Remember** to follow the steps **NPM init** provides for you! **WINDOWS** users, after the last prompt, if process does not quit, simply **Ctrl+D** to exit.\n\nCreate an **index.js** file for Node\n\n```bash\ntouch index.js\n```\n\nCreate a folder called **public**.\n\n```bash\nmkdir public\n```\n\nInside your **public** folder, create the usual files and folders you would for a regular website.\n\n```bash\ncd public\nmkdir styles js\ntouch index.html js/app.js styles/main.css\n```\n\nOpen up your entire **node-server** project on sublime, write some sample code in your **index.js** file, and test run to ensure it is working fine.\n\n## Exercise 2\n\nThere are a few modules that we will be working with tonight.\n\nInstall each module as follows:\n\n```bash\nnpm install --save-dev nodemon\nnpm install --save cookies\n```\n\n**Question**: what is the point of **--save**? How about **--save-dev**?\n\n","idx":3},"server-basics":{"content":"# Server Basics\n\nFirst, let's define some important terminology.\n\n## Define: Server\n\nA **server**, specifically a **web server**, is a piece of software that continuously listens for **HTTP requests** on a specified **port**. It handles these **HTTP requests** in various ways, interfacing with the internal filesystem **or** database and issues a **response**. The **response** can be anything, though typically it is usually **HTML** or **JSON** strings. **Clients**, typically web browsers, handle this **response** by parsing it and rendering it (either as a webpage or a formatted JSON string).\n\n## Define: Port\n\nA port is device that transfers information between an internet connection and a computer. You can think of it as the doorman in the lobby of an office building. Typically, a computer will have multiple ports, so when establishing a new server we have to specify **which** port (numeric) we should listen to (for HTTP requests).\n\n## Define: HTTP Request\n\nA HTTP request defines a client asking our server for some piece of information. Typically, the request contains information that further describes the request. This information comes in a few flavors:\n\n### Request Types\nCan be either **GET**, **POST**, **PUT**, or **DELETE**. There are a few others that are supported but not super widely used, so we'll stick to these for now.\n\n**GET**: This is the most common, every time we load a page on a browser, we are issuing a **GET** request to a server. Think of **GETs** as **read** requests.\n\n**POST**: This - most often - is used to create a new record of something on the server. When we log in to a web server (ie: facebook) **or** if we create a new account or new tweet, IG post, etc - we are usually issuing a **POST** request. \n\n**PUT**: The **PUT** is typically used to update an existing record. When we edit a comment on IG/facebook or if we are updating our user profile somewhere, we are usually issuing a **PUT** request.\n\n**DELETE**: As the name suggests, we typically issue **DELETE** requests when we want to remove a specific record.\n\nThese four request types can be combined to create what we call a **CRUD** app. More on that later tho.\n\n### Request Body\n\nWhen issuing a **PUT**, **POST**, or **DELETE** request, we can optionally pass in a data payload from the client. This data payload is usually either JSON (ie: javascript object that has been converted to a string) **or** it's encoded, ampersand-ed form data.\n\n### Request Params\n\nRemember the `?foo=bar&baz=1&etc=2` strings we observed while working with AJAX on the frontend? These **query params** are passed in to the server by the client - where they can be parsed and used as arguments of a serverside function (or for conditional logic).\n\n### Request Headers\n\nAdditional bits of information that is helpful to the server to parse, understand, and properly respond to a client request. \n\nHere's an example of a header: `Content-Type: application/json`. \n\n^^^ This tells the server that the **request body** of this particular request is formatted as JSON and not form data.\n\n## Define: HTTP Response\n\nA HTTP response is what the server sends back to the client along with (hopefully) the data requested. Usually, this works in a very similar way that the **http request** does. \n\n## Exercise\n\nLet's create a simple NodeJS server of our own.\n\nConsider the following code:\n\n```js\nconst http = require('http');\nconst port = 8008;\n\nconst onRequest = (request, response) => {...}\nconst server = http.createServer(router);\n\nserver.listen(port, (err) => {  \n  if (err) {\n    return console.log(err)\n  }\n\n  console.log(`server is listening on http://localhost:${port}`)\n})\n```\n\nMove this over to your **index.js**. Parse through it and try to understand what it does. \n\n### Task 1\nUsing the **[documentation for http](https://nodejs.org/api/http.html#http_http)**, have your program `console.log` the **url** of a HTTP request that is sent to your server.\n\n### Task 2\n\nUsing the **[documentation for http](https://nodejs.org/api/http.html#http_http)**, have your program issue a server **response** to the client with the text **Hello, Wrold from NodeJS Server**.\n\n### Stretch Goals\n\n1. Send out **two** different flavors of response, based on **request** url.\n2. Send out the **request.url** and **request.method** values to the client as well.\n\n\n\n","idx":4},"simple-get-requests":{"content":"# Simple GET Requests\n\nLet's improve our HTTP Server\n\n## Exercise\n\nWe will update our server with a few powerups...\n\nLet's first define some routes. **Routes** are url fragments that define specific, known requests that the client could make. In the event of those requests, let's response with some pertinent information.\n\n### Task 1\n\nUsing the `request.url` property in `onRequest`, determine if a request URL is either:\n\n1. `/index.html`\n2. `/index.json`\n\nIf the request is for `/index.html`, then respond with the following **html** code:\n\n```html\n'<h1>Hello, Wrold from NodeJS!</h1>`\n```\n\n**NOTE**: on the client, this **must** render as html, meaning your content should be bolded from the default **h1** styles.\n\nIf the request is for `/index.json`, then respond with the following **json** code:\n\n```js\n{\"content\": 'Hello, Wrold from NodeJS'}\n```\n\nNOTE: on the client, this **must** render as a JSON string.\n\n### Life Hack\n\nRemember our friend **nodemon**? Here's his time to shine!\n\nIn terminal, run this:\n\n```bash\n./node_modules/.bin/nodemon index.js\n```\n\n^^^ Doing this will init **nodemon**, which will **watch** your index.js file - everytime you make a change to it, it will **automatically** restart your server so you don't have to keep killing and re-running your **index.js** file. \n\n### #Stretch Goals\n\nMove your server code into a new file, **server.js**. Wrap your code around a function, let's call it `initServer` that takes one argument, a `<Number>` called `port`.\n\nModule export this `initServer` function.\n\nIn your **index.js**, use the `npm commander` module to create a CLI script that takes an arg, `-p` or `--port` to create a new server at any port your supply. **Default** this to port **8008**.\n\n\n","idx":5},"routing":{"content":"# Routing\n\nNow that we got the basics working, let's get **serious**.\n\n## Requirements\n\nWe are to build a functioning and **extensible** server application. For now, we will only be handling **GET** requests, but our code should be able to easily deal with **PUT**, **POST**, and **DELETE** requests as well, when we are ready to add support for these request types.\n\nHere are some more granular directives on how this server should work:\n\n1. We are to export a function called **router** that is to be imported from our server file. \n2. `router` takes two arguments - the **request**, **response** params from `http.createServer`\n3. In `router`, we check the `request.url` against a list of our own, supported routes. If one is found, we run a method that handles how to respond to the client. \n4. if **no** support route is found, we issue a **404** with a custom, **not found** html message.\n\n## Exercises\n\nLet's break up all this into smaller, more manageable tasks to tackle.\n\n### Task 1\n\nCreate a new file, call it `router.js`. At the most basic level, `router.js` should look like this:\n\n```js\nconst router = (request, response) => {\n    // ... implement stuff here ...\n};\nmodule.exports = router;\n```\n\nIn your **index.js**, modify the `http.createServer` method to use this exported `router` function.\n\n### Task 2\n\nNow comes the fun part. Let's define our routes in an extensible manner.\n\nIn your `router.js` file, create a new object, like so:\n\n```js\nconst routes = {};\nconst router = (request, response) => {\n    // ... implement stuff here ...\n};\nmodule.exports = router;\n```\n\nYour `routes` object can now defined routes like so:\n\n```js\nroutes['/index.html'] = (request, response) => {\n    // .. specifically handle this route .. \n}\n```\n\nAdd a few specific **html** routes to your `route` object. Then, in your `router` function, write the necessary logic needed to call each of those functions you defined if `request.url` matches one of your **predefined** `routes`. \n\n**#stretchgoal**: what if you wanted **two** or **more** routes to return the same exact response? How would you achieve that in this above configuration?\n\nTest your code to ensure that it works as you expect it to! Remember, since these are **.html** routes, we want to pass back **html** that is properly rendered!\n\n### Task 3\n\nOk, great - but what if the client requests a route that doesn't exist? Update your `router` function in the `router.js` file to respond with a **404** status code and some accompanying **html** code if the task being requested is not found.\n\n### Task 4\n\n...but what about **APIs** tho? This is an open ended question, but how would you update your `router.js` file, specifically your `routes` object to handle **API** routes that need to respond with **JSON** strings and not **HTML**?\n\n### Task 5/#stretchgoal\n\nFilter against non-supported **request methods**! If the client is requesting anything that is not (for now) a **GET** request, issue a response that is **400 Bad Request**. \n\n\n\n","idx":6},"simple-post-requests":{"content":"# Simple POST Requests\n\nNow, let's add some support for **POST** requests.\n\n## How to make POST calls\n\nFirstly, let's talk about how we can even possibly test this.\n\nAs you know, all URL calls from within the browser (the ultimate HTTP client) are **GET** requests by default.\n\nTo issue a **POST** request, we must use the **terminal** and the **cURL** command.\n\nConsider the following:\n\n```bash\ncurl \\\n    -H \"Content-Type: application/json\" \\\n    -X POST \\\n    -d '{\"username\":\"xyz\",\"password\":\"xyz\"}' \\\n    http://localhost:3000/api/login\n```\n\nIn this example, the **\\** is a way for us to make newlines (for easier reading).\n\nAdditionally:\n\n* **-H**: headers to pass. If we wish to send **request body** that is **json**, we must pass `Content-Type: application/json`\n* **-X**: the request type. Of course, in this case we would like **POST**.\n* **-d**: the data payload. Since our `content-type` is json, we must provide a valid JSON string\n\nAnd finally, the last line - the actual **url route** we wish to post to. \n\nTo practice, try to **cURL** all of **[google's](https://www.google.com)** homepage HTML. You should use something like this:\n\n```bash\ncurl \\\n    -X GET\n    https://www.google.com\n```\n\n## Exercise\n\nNow, we will extend our `router.js` file to support **POST** calls as well!\n\n### Task 1\n\nFirst, update your `router` function to allow both **GET** and **POST** method requests (but not **DELETE** nor **PUT**).\n\n(This should be an easy one...)\n\n### Task 2\n\nNow, let's get serious. **Question**: how can you discern between an **API** request and a simple/normal **HTML** request?\n\nThis is an open ended question with a few options. Presented below is simple **one** of the available options you have.\n\nTake your `routes` object and do the following:\n\n```js\nconst routes = {};\n// ... a bunch of routes we already defined ...\n// should look like...\n// routes['/index.html'] = (...) => {...}\n\n// here is where things get interesting\nroutes.api = {};\nroutes.api['/index.json'] = (...) => {...}\n```\n\nNow, in your `router` function, you can easily do something like this:\n\n```js\nconst router = (...) => {\n    if (request.url.indexOf('.json') !== -1) {\n        // .. call your routes.api url here ..\n    }\n}\n```\n\n**Question**: how can you update the code above to support something like `/api/index.html` in the client request?\n\nAlso, how would you return **purely** json in the response to **API** requests only?\n\n### Task 3\n\nLast important task - **how do we read the request body**?\n\nAs it turns out, this is non trivial. The request body is **streamed**, which is a node-y way to transfer data that may not necessarily be small in size.\n\nTo capture our **request body**, you would do something like this:\n\n```js\nconst body = [];\nrequest\n    .on('data',(chunk) => {\n        body.push(chunk);\n    })\n    .on('end',() => {\n        const data = Buffer.concat(body).toString();\n    });\n```\n\n**Question**: where would you place this information to make it useful? For now, our post requests should only relay back whatever data payload was sent to the endpoint.\n","idx":7},"serving-a-full-webpage":{"content":"# Serving a full webpage\n\nHaving learned all of this, how do we use our knowledge to accomplish the most basic task: have our server relay back a fully qualified webpage?\n\n## Exercise\n\nRemember our `/public` folder? It had a `styles` directory, a `js` directory, some js and css content and an **index.html**.\n\nHow would we configure our server to serve all of that content with minimal configuration?\n\n### Task\n\nUpdate our server code so that *any* file under the `/public` directory is relayed straight to the client.\n\n**Hint 1**: to accomplish this, you will need your trusty `fs-promise.js`\n\n**Hint 2**: you will also need the `indexOf` method on the `request.url` property\n\n**Hint 3**: to test, if you point your url to `localhost:[port]/public/index.html`, you should expect it to load your entire static webpage, complete with js file and css file loading and rendering.\n","idx":8},"serving-json-content":{"content":"# Serving JSON Content\n\n#TBD!","idx":9},"__list__":["home","title","desc","warmup","server-basics","simple-get-requests","routing","simple-post-requests","serving-a-full-webpage","serving-json-content"]}